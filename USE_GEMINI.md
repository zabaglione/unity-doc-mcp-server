# 大規模コードベース分析に Gemini CLI を使用する

大規模なコードベースやコンテキスト制限を超える可能性のある複数のファイルを解析する場合は、Gemini CLIの強力な
コンテキストウィンドウ。Google Gemini の大きなコンテキスト容量を活用するには、`gemini -p` を使用します。

## ファイルとディレクトリのインクルード構文

Geminiプロンプトにファイルやディレクトリを含めるには、`@`構文を使用します。パスは、Geminiを実行する場所からの相対パスで指定します。
  geminiコマンド:

### 例:

**単一ファイル分析:**
gemini -p "@src/main.py このファイルの目的と構造を説明します"

複数のファイル:
gemini -p "@package.json @src/index.js コードで使用されている依存関係を分析する"

ディレクトリ全体:
gemini -p "@src/ このコードベースのアーキテクチャを要約する"

複数のディレクトリ:
gemini -p "@src/ @tests/ ソースコードのテストカバレッジを分析する"

現在のディレクトリとサブディレクトリ:
gemini -p "@./ このプロジェクト全体の概要を教えてください"

# または --all_files フラグを使用します:
gemini --all_files -p "プロジェクトの構造と依存関係を分析する"

実装検証例

機能が実装されているかどうかを確認します。
gemini -p "@src/ @lib/ このコードベースにダークモードは実装されていますか？関連するファイルと関数を表示してください"

認証実装を確認します。
gemini -p "@src/ @middleware/ JWT認証は実装されていますか？認証関連のエンドポイントとミドルウェアをすべて一覧表示します"

特定のパターンを確認します。
gemini -p "@src/ WebSocket接続を処理するReactフックはありますか？ファイルパスとともにリストしてください"

エラー処理を確認します。
gemini -p "@src/ @api/ すべてのAPIエンドポイントに適切なエラー処理が実装されていますか？ try-catchブロックの例を示す"

レート制限を確認します:
gemini -p "@backend/ @middleware/ API にレート制限が実装されていますか？実装の詳細を表示します"

キャッシュ戦略を確認します。
gemini -p "@src/ @lib/ @services/ Redis キャッシュは実装されていますか？ キャッシュ関連の関数とその使用方法をすべて一覧表示します"

具体的なセキュリティ対策を確認してください:
gemini -p "@src/ @api/ SQLインジェクション保護は実装されていますか？ ユーザー入力がどのようにサニタイズされるかを表示します"

機能のテスト範囲を確認します。
gemini -p "@src/payment/ @tests/ 支払い処理モジュールは完全にテストされていますか？すべてのテストケースを一覧表示します"

Gemini CLI を使用する場合

次の場合に gemini -p を使用します:
- コードベース全体または大規模なディレクトリの分析
- 複数の大きなファイルの比較
- プロジェクト全体のパターンやアーキテクチャを理解する必要がある
- 現在のコンテキストウィンドウはタスクには不十分です
- 合計100KBを超えるファイルの操作
- 特定の機能、パターン、またはセキュリティ対策が実装されているかどうかを確認する
- コードベース全体にわたって特定のコーディングパターンの存在を確認する

重要な注意事項

- @ 構文内のパスは、gemini を呼び出すときに現在の作業ディレクトリからの相対パスになります。
- CLIはコンテキストにファイルの内容を直接含めます
- 読み取り専用分析では --yolo フラグは不要
- Geminiのコンテキストウィンドウは、Claudeのコンテキストではオーバーフローしてしまうようなコードベース全体を処理できる。
- 実装を確認する際は、正確な結果を得るために何を探しているのかを具体的にしてください
